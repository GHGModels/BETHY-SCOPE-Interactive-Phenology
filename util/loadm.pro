PRO loadm, file, data, years, FORMAT = frm, GRIDWIDTH = grw, EQUAL = equ, LONLAT = lonlat, $                       OCEAN = ocvalue, BAND = bnd, COLUMNS = clms, $                       SKIP = skip, NW = nw, CENTER = center, INT = int, SUM = sum, $                       YEAR = year, SHIFT = shift, ACTUALYEAR = actualyear                       ; program to load global map of 0.5 degree resolution; formatted as a list containing; latitude longitude, and 12 montly values;; INPUT:; file      filename of map; OUTPUT:; data      monthly field; years     array containing [startyear,endyear]; KEYWORDS:; format    read format for the 12 monthly values (default: list directed input); gridwidth width of grid pixels in degrees, default is 0.5; lonlat    read longitude first, then latitude (default is the reverse); ocean     value for pixels not contained in the data set (default is 0.0); band      if set, only one-dimensional input expected;           1: longitudinal band (i.e. N - S transect);              longitude value is ignored;           2: latitudinal band (i.e. W - E transect);              latitude value is ignored;           3: only one grid point; columns   number of entries per lat/lon (default is 12); skip      number of lines to skip at the beginning; nw        lat/lon indicates NW corner (default is SW); center    lat/lon indicates center of pixel (default is SW corner); sum       1: set ocean to 0 and sum up entries;           2: set ocean to 0 and compute mean of entries;           ONLY VALID, IF band = 0; equal     fill gaps in equal-area projection, where equatorial;           equals latitudinal resolution; invokes option 'center'; year      if set, interannual data is expected;           single value 'n': year n is extracted (year=0: first year);           double value '[n1,n2]': years n1 to n2 are extracted;           -1: read all years in record; shift     shift east by half grid cell;           (for grids with cell center at date line etc.); actualyear   if set together with year, the actual years of the data;              set are returned in 'years', else years(0) is always 0OPENR, unit, file, /GET_LUNIF NOT KEYWORD_SET (grw) THEN grw = 0.5grwx = grwgrwy = grwIF N_ELEMENTS (grw) EQ 2 THEN BEGIN  grwx = grw(0)  grwy = grw(1)ENDIFnx = FIX (360. / grwx)ny = FIX (180. / grwy)IF KEYWORD_SET (clms) THEN nz = clms ELSE nz = 12nyrs = 1in0 = FLTARR(nz)line_read = 0IF KEYWORD_SET (year) THEN BEGIN  IF year(0) EQ -1 THEN BEGIN    IF KEYWORD_SET (actualyear) THEN $    READF, unit, lat, lon, nyears, year0 ELSE $    READF, unit, lat, lon, nyears    nyrs = FIX (nyears)    year = [0, nyrs - 1]    IF KEYWORD_SET (actualyear) THEN year = year + year0    nz = nz * nyrs    line_read = 1  ENDIF ELSE BEGIN    IF N_ELEMENTS (year) EQ 2 THEN BEGIN      nyrs = FIX (year(1) - year(0) + 1)      nz = nz * nyrs    ENDIF  ENDELSEENDIFin = FLTARR(nz)IF NOT KEYWORD_SET (ocvalue) THEN ocvalue = 0.0IF KEYWORD_SET (sum) THEN ocvalue = 0.0IF KEYWORD_SET (int) THEN BEGIN                                ; ARRAY SETUP  IF KEYWORD_SET (bnd) THEN BEGIN    IF bnd eq 1 THEN data = REPLICATE (FIX(ocvalue), ny, nz)    IF bnd eq 2 THEN data = REPLICATE (FIX(ocvalue), nx, nz)    IF bnd eq 3 THEN data = REPLICATE (FIX(ocvalue), nz)  ENDIF ELSE BEGIN    data = REPLICATE (FIX(ocvalue), nx, ny, nz)  ENDELSE  fac = intENDIF ELSE BEGIN  IF KEYWORD_SET (bnd) THEN BEGIN    IF bnd eq 1 THEN data = REPLICATE (FLOAT(ocvalue), ny, nz)    IF bnd eq 2 THEN data = REPLICATE (FLOAT(ocvalue), nx, nz)    IF bnd eq 3 THEN data = REPLICATE (FLOAT(ocvalue), nz)  ENDIF ELSE BEGIN    data = REPLICATE (FLOAT(ocvalue), nx, ny, nz)  ENDELSE  fac = 1.ENDELSEIF KEYWORD_SET (frm) THEN BEGIN  frmt = '(F6.1, F7.1, ' + STRTRIM (nz,2) + frm + ')'  IF STRMID (frm, 0, 1) EQ '(' THEN frmt = frmENDIFIF KEYWORD_SET(skip) THEN BEGIN  line = ""  FOR i = 1, skip DO readf, unit, lineENDIFIF KEYWORD_SET (sum) THEN BEGIN  count = FIX (data(*,*,0)) * 0ENDIFWHILE NOT EOF(unit) DO BEGIN  IF N_ELEMENTS (year) EQ 0 THEN BEGIN    IF KEYWORD_SET (frm) THEN $      READF, unit, lat, lon, in, FORMAT = frmt $  ; READING DATA      ELSE READF, unit, lat, lon, in              ; (SINGLE YEAR)  ENDIF ELSE BEGIN    IF line_read THEN line_read = 0 ELSE BEGIN      IF KEYWORD_SET (actualyear) THEN $      READF, unit, lat, lon, nyears, year0 ELSE $      READF, unit, lat, lon, nyears                 ; READING DATA    ENDELSE    FOR yr = 0, nyears - 1  DO BEGIN              ; (MULTI YEAR)      yyr = yr      IF KEYWORD_SET (actualyear) THEN yyr = yyr + year0      IF NOT KEYWORD_SET (frm) THEN READF, unit, in0 ELSE $        READF, unit, in0, FORMAT = '(' + STRTRIM (nz,2) + frm + ')'      IF yyr GE year(0) AND yyr LT year(0) + nyrs THEN BEGIN        z0 = (yyr-year(0))*nz/nyrs        in(z0:z0+nz/nyrs-1) = in0      ENDIF    ENDFOR  ENDELSE  IF KEYWORD_SET(lonlat) THEN BEGIN    tmp = lat    lat = lon    lon = tmp  ENDIF  IF KEYWORD_SET (shift) THEN $  ; shift by half grid point eastwards     lon = lon + 0.5 * 360. / nx  IF NOT KEYWORD_SET (equ) AND NOT KEYWORD_SET (center) THEN BEGIN    lon = lon + 0.5 * 360. / nx    IF KEYWORD_SET (nw) THEN BEGIN      lat = lat - 0.5 * 180. / ny    ENDIF ELSE BEGIN      lat = lat + 0.5 * 180. / ny    ENDELSE  ENDIF  x = FIX ((lon + 180.) * nx / 360.)  y = FIX ((lat + 90.) * ny / 180.)  IF KEYWORD_SET (equ) THEN BEGIN     n = FIX (360./ grw * COS (lat * !pi / 180.) + 0.5)     x = FIX ((lon + 180.) * n / 360.)     lon1 = x * 360. / n - 180.     lon2 = (x+1) * 360. / n - 180.     x1 = FIX ((lon1 + 180.) * nx / 360. + 0.5)     x2 = FIX ((lon2 + 180.) * nx / 360. + 0.5) - 1  ENDIF ELSE BEGIN     x1 = x     x2 = x  ENDELSE  FOR x0 = x1, x2 DO BEGIN  x = x0 MOD nx  IF KEYWORD_SET (sum) THEN BEGIN    IF KEYWORD_SET (bnd) THEN BEGIN      IF bnd eq 1 THEN data(y,*) = data(y,*) + in * fac      IF bnd eq 2 THEN data(x,*) = data(x,*) + in * fac      IF bnd eq 3 THEN data(*) = data(*) + in * fac    ENDIF ELSE BEGIN      IF nz EQ 1 THEN data(x,y) = data(x,y) + in * fac $        ELSE data(x,y,*) = data(x,y,*) + in * fac      count(x,y) = count(x,y) + 1     ENDELSE  ENDIF ELSE BEGIN    IF KEYWORD_SET (bnd) THEN BEGIN      IF bnd eq 1 THEN data(y,*) = in * fac      IF bnd eq 2 THEN data(x,*) = in * fac      IF bnd eq 3 THEN data(*) = in * fac    ENDIF ELSE BEGIN      IF nz EQ 1 THEN data(x,y) = in * fac ELSE data(x,y,*) = in * fac    ENDELSE  ENDELSE  ENDFORENDWHILEFREE_LUN, unitIF KEYWORD_SET (sum) AND NOT KEYWORD_SET (bnd) THEN BEGIN  IF sum EQ 2 THEN $    FOR z = 0, nz - 1 DO data(*,*,z) = data(*,*,z) / (count(*,*) > 1)ENDIFyears = [0, nyrs - 1]IF N_ELEMENTS (year0) GT 0 THEN years = years + year0END